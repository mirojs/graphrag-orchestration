# HANDOVER — 2026-02-16 (Sunday)

## Objective

Migrated **all** production vector queries from `db.index.vector.queryNodes()` (post-filter)
to Neo4j's native **`SEARCH` clause** with in-index `group_id` pre-filtering.

This eliminates the cross-group contamination bug permanently and scales to arbitrary
numbers of groups/OIDs without oversampling hacks.

---

## Background (from Feb 15)

Yesterday's handover documented the cross-group vector index contamination bug:
- Shared vector indexes return global top-k, then `WHERE node.group_id = $gid` filters
  **after** the ANN scan — minority groups get 0 results
- Tactical fix: label archiving (`Entity` → `EntityArchived`) — manual, mutually exclusive
- The oversampling hack (`top_k * 10`) is fragile and doesn't scale

## Solution: SEARCH Clause with Filtered Vector Indexes

### Mechanism

Neo4j 5.18+ (Cypher 25) supports `SEARCH ... IN (VECTOR INDEX ... WHERE ... LIMIT)`:

```cypher
CYPHER 25
MATCH (e:Entity)
SEARCH e IN (VECTOR INDEX entity_embedding_v2 FOR $emb WHERE e.group_id = $gid LIMIT 3)
SCORE AS score
RETURN e.name, score
```

This pushes the WHERE predicate **into** the HNSW scan. Requires indexes created with:

```cypher
CREATE VECTOR INDEX entity_embedding_v2 IF NOT EXISTS
FOR (e:Entity) ON (e.embedding_v2)
WITH [e.group_id]   -- <-- NEW: declares filterable properties
OPTIONS {indexConfig: {
    `vector.dimensions`: 2048,
    `vector.similarity_function`: 'cosine'
}}
```

### Validated on AuraDB 5.27

- PROFILE shows single `NodeVectorIndexSearch` operator (db_hits=4 for 3 results)
- Old approach: `ProcedureCall` + separate `Filter@neo4j` (db_hits=200 for 3 results)
- Group isolation confirmed — zero cross-group leakage

---

## Changes Made

### 1. Migration Script

**New file:** `scripts/migrate_vector_indexes_filtered.py`

```bash
# Dry run (show what would happen):
python scripts/migrate_vector_indexes_filtered.py --dry-run --restore-labels

# Production run (V2 indexes only):
python scripts/migrate_vector_indexes_filtered.py --restore-labels

# Include V1 legacy indexes:
python scripts/migrate_vector_indexes_filtered.py --include-v1 --restore-labels

# Verify only (after migration):
python scripts/migrate_vector_indexes_filtered.py --verify-only
```

The script:
1. Drops test index `entity_embedding_v2_filtered` (from yesterday's probing)
2. Optionally restores `:EntityArchived` → `:Entity` labels (reverses yesterday's workaround)
3. Drops existing V2 indexes (IF NOT EXISTS won't add WITH to existing)
4. Recreates with `WITH [*.group_id]`
5. Waits for ONLINE status (up to 10 min)
6. Verifies SEARCH clause works via PROFILE

### 2. Index Creation Code Update

**`src/worker/hybrid_v2/services/neo4j_store.py`** — `ensure_schema()` vector index DDL
now includes `WITH [*.group_id]` for all V2 indexes:
- `entity_embedding_v2` — `WITH [e.group_id]`
- `entity_embedding_v2_internal` — `WITH [e.group_id]`
- `chunk_embeddings_v2` — `WITH [t.group_id]`
- `sentence_embeddings_v2` — `WITH [s.group_id]`

### 3. Production Query Migrations (15 sites)

All `db.index.vector.queryNodes()` calls converted to `SEARCH` clause:

| File | Sites | Index | Notes |
|------|-------|-------|-------|
| `async_neo4j_service.py` | 2 | `entity_embedding_v2` | get_entities_by_vector_similarity + beam HOP 0 |
| `hipporag_retriever.py` (v2) | 1 | `entity_embedding_v2` | Sync driver, manual `CYPHER 25` prefix |
| `route_2_local.py` | 2 | `sentence_embeddings_v2` | Strategy A + Strategy B anchor |
| `route_3_global.py` | 1 | `sentence_embeddings_v2` | Diversity fetch_k passed as LIMIT |
| `route_4_drift.py` | 1 | `sentence_embeddings_v2` | Sentence similarity search |
| `base.py` | 1 | `chunk_embeddings_v2` | Inside RRF CALL {} subquery |
| `neo4j_store.py` (v2) | 2 | `entity_embedding` / `sentence_embeddings_v2` | search_entities_by_embedding + query_sentences_by_vector |
| `text_store.py` | 1 | `chunk_embeddings_v2` | f-string for index name (SEARCH needs literal) |
| `neo4j_hybrid_search.py` | 2 | `entity` / `chunk_vector` | V1 legacy via structured_query |
| `neo4j_standalone_store.py` | 1 | various (label map) | Generic vector_query with label inference |
| `graphrag_query_engine.py` | 1 | `entity` | V1 legacy |
| `hipporag_retriever.py` (v1) | 1 | `entity_embedding` | V1 legacy |
| `hybrid/orchestrator.py` | 3 | `chunk_embedding` | V1 legacy RRF + standalone vector |
| `hybrid/services/neo4j_store.py` | 1 | `entity_embedding` | V1 legacy |

### 4. Intentionally NOT Updated

- **`api_gateway/routers/hybrid.py`** (`debug_test_vector_search` endpoint, lines 1890–1996):
  Diagnostic endpoint that deliberately tests the OLD approach to demonstrate the
  cross-group contamination bug. Kept as-is for debugging.

---

## Key Pattern Change

**Before (oversampling hack):**
```cypher
CALL db.index.vector.queryNodes('index', $top_k * 10, $embedding)
YIELD node, score
WHERE node.group_id = $group_id
ORDER BY score DESC
LIMIT $top_k
```

**After (SEARCH clause with in-index filtering):**
```cypher
CYPHER 25
MATCH (node:Label)
SEARCH node IN (VECTOR INDEX index FOR $embedding WHERE node.group_id = $group_id LIMIT $top_k)
SCORE AS score
ORDER BY score DESC
```

Key differences:
- `CYPHER 25` prefix required (via `cypher25_query()` helper or manual prefix)
- `SEARCH` requires literal index name (not `$parameter`) — use f-string when dynamic
- No oversampling — SEARCH guarantees exact top_k results for the filtered group
- `SCORE AS score` replaces `YIELD node, score`
- Threshold filters move to `WITH sent, score WHERE score >= $threshold` after SEARCH

---

## Deployment Sequence

**⚠ CRITICAL: Indexes must be migrated BEFORE deploying code changes.**

The SEARCH clause will fail if indexes lack the `WITH [group_id]` filter property.

1. **Run migration script** (with `--dry-run` first):
   ```bash
   python scripts/migrate_vector_indexes_filtered.py --restore-labels
   ```
2. **Wait for all indexes to reach ONLINE** (script waits automatically, ~2-5 min)
3. **Deploy code changes**
4. **Verify** — run the migration script with `--verify-only`:
   ```bash
   python scripts/migrate_vector_indexes_filtered.py --verify-only
   ```

---

## Neo4j State (Current)

- **Server**: AuraDB 5.27 Enterprise, Cypher versions ['5', '25']
- **Label state**: 368 `:Entity` nodes (test-5pdfs-v2-fix2), 6594 `:EntityArchived` (other groups)
- **Test index**: `entity_embedding_v2_filtered` still exists (will be dropped by migration script)
- **Production indexes**: Still use old schema (no WITH clause) until migration is run

---

## Risk Assessment

| Risk | Mitigation |
|------|------------|
| SEARCH fails if index lacks WITH | Migration script must run first; `IF NOT EXISTS` won't add WITH to existing indexes |
| V1 indexes not recreated | Use `--include-v1` flag; V1 paths are legacy but still reachable |
| Label restore timeout | Batched 1000-at-a-time; 6594 nodes = ~7 batches |
| Index rebuild time | ~2-5 min for V2 indexes on current data size; script waits up to 10 min |
| Cypher 25 not available | `USE_CYPHER_25 = True` already set; AuraDB 5.27 supports it |

---

## Files Changed

```
NEW:  scripts/migrate_vector_indexes_filtered.py
EDIT: src/worker/hybrid_v2/services/neo4j_store.py      (index creation + 2 queries)
EDIT: src/worker/services/async_neo4j_service.py         (2 queries)
EDIT: src/worker/hybrid_v2/retrievers/hipporag_retriever.py (1 query)
EDIT: src/worker/hybrid_v2/routes/route_2_local.py       (2 queries — pre-existing from earlier edit)
EDIT: src/worker/hybrid_v2/routes/route_3_global.py      (1 query)
EDIT: src/worker/hybrid_v2/routes/route_4_drift.py       (1 query)
EDIT: src/worker/hybrid_v2/routes/base.py                (1 query in RRF)
EDIT: src/worker/hybrid_v2/indexing/text_store.py        (1 query)
EDIT: src/worker/services/neo4j_hybrid_search.py         (2 queries)
EDIT: src/worker/services/neo4j_standalone_store.py      (1 query)
EDIT: src/worker/services/graphrag_query_engine.py       (1 query)
EDIT: src/worker/hybrid/retrievers/hipporag_retriever.py (1 query)
EDIT: src/worker/hybrid/orchestrator.py                  (3 queries)
EDIT: src/worker/hybrid/services/neo4j_store.py          (1 query)
```

## Next Steps

1. **Run migration script** on AuraDB (indexes must exist before code deployment)
2. **Deploy code** — all vector queries now use SEARCH clause
3. **Benchmark** — compare latency/quality with old approach
4. **Add OID filtering** — when org isolation is needed, add `oid` to `WITH [*.group_id, *.oid]`
   and update SEARCH WHERE to include `AND node.oid = $oid`
5. **Remove label archiving** — `EntityArchived` workaround is obsolete once filtered indexes are live
